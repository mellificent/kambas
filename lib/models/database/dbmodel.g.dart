// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'dbmodel.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

// ignore_for_file: non_constant_identifier_names

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:UserAccount.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// BEGIN TABLES
// UserAccount TABLE
class TableUserAccount extends SqfEntityTableBase {
  TableUserAccount() {
    // declare properties of EntityTable
    tableName = 'userAccounts';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('userId', DbType.integer),
      SqfEntityFieldBase('userName', DbType.text),
      SqfEntityFieldBase('fullName', DbType.text),
      SqfEntityFieldBase('email', DbType.text),
      SqfEntityFieldBase('contactNo', DbType.text),
      SqfEntityFieldBase('password', DbType.text),
      SqfEntityFieldBase('createdAt', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('updatedAt', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableUserAccount();
  }
}

// KambasTransaction TABLE
class TableKambasTransaction extends SqfEntityTableBase {
  TableKambasTransaction() {
    // declare properties of EntityTable
    tableName = 'kambasTransactions';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('createdAt', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('username', DbType.text),
      SqfEntityFieldBase('ticketSeries', DbType.text),
      SqfEntityFieldBase('hasRead', DbType.bool, defaultValue: false),
      SqfEntityFieldBase('jsonResponse', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableKambasTransaction();
  }
}

// KambasTerminal TABLE
class TableKambasTerminal extends SqfEntityTableBase {
  TableKambasTerminal() {
    // declare properties of EntityTable
    tableName = 'kambasTerminal';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('stallName', DbType.text, defaultValue: ''),
      SqfEntityFieldBase('location', DbType.text, defaultValue: ''),
      SqfEntityFieldBase('agent', DbType.text, defaultValue: ''),
      SqfEntityFieldBase('ticketNumber', DbType.text, defaultValue: ''),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableKambasTerminal();
  }
}
// END TABLES

// BEGIN SEQUENCES
// identity SEQUENCE
class SequenceIdentitySequence extends SqfEntitySequenceBase {
  SequenceIdentitySequence() {
    sequenceName = 'identity';
    maxValue =
        9007199254740991; /* optional. default is max int (9.223.372.036.854.775.807) */
    cycle = false; /* optional. default is false; */
    minValue = 0; /* optional. default is 0 */
    incrementBy = 1; /* optional. default is 1 */
    startWith = 0; /* optional. default is 0 */
    super.init();
  }
  static SequenceIdentitySequence? _instance;
  static SequenceIdentitySequence get getInstance {
    return _instance = _instance ?? SequenceIdentitySequence();
  }
}
// END SEQUENCES

// BEGIN DATABASE MODEL
class KambasDB extends SqfEntityModelProvider {
  KambasDB() {
    databaseName = mKambasDbModel.databaseName;
    password = mKambasDbModel.password;
    dbVersion = mKambasDbModel.dbVersion;
    preSaveAction = mKambasDbModel.preSaveAction;
    logFunction = mKambasDbModel.logFunction;
    databaseTables = [
      TableUserAccount.getInstance,
      TableKambasTransaction.getInstance,
      TableKambasTerminal.getInstance,
    ];

    sequences = [
      SequenceIdentitySequence.getInstance,
    ];

    bundledDatabasePath = mKambasDbModel
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
    databasePath = mKambasDbModel.databasePath;
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region UserAccount
class UserAccount extends TableBase {
  UserAccount(
      {this.id,
      this.userId,
      this.userName,
      this.fullName,
      this.email,
      this.contactNo,
      this.password,
      this.createdAt,
      this.updatedAt,
      this.isDeleted}) {
    _setDefaultValues();
    softDeleteActivated = true;
  }
  UserAccount.withFields(
      this.userId,
      this.userName,
      this.fullName,
      this.email,
      this.contactNo,
      this.password,
      this.createdAt,
      this.updatedAt,
      this.isDeleted) {
    _setDefaultValues();
  }
  UserAccount.withId(
      this.id,
      this.userId,
      this.userName,
      this.fullName,
      this.email,
      this.contactNo,
      this.password,
      this.createdAt,
      this.updatedAt,
      this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  UserAccount.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['userId'] != null) {
      userId = int.tryParse(o['userId'].toString());
    }
    if (o['userName'] != null) {
      userName = o['userName'].toString();
    }
    if (o['fullName'] != null) {
      fullName = o['fullName'].toString();
    }
    if (o['email'] != null) {
      email = o['email'].toString();
    }
    if (o['contactNo'] != null) {
      contactNo = o['contactNo'].toString();
    }
    if (o['password'] != null) {
      password = o['password'].toString();
    }
    if (o['createdAt'] != null) {
      createdAt = int.tryParse(o['createdAt'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['createdAt'].toString())!)
          : DateTime.tryParse(o['createdAt'].toString());
    }
    if (o['updatedAt'] != null) {
      updatedAt = int.tryParse(o['updatedAt'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['updatedAt'].toString())!)
          : DateTime.tryParse(o['updatedAt'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;
  }
  // FIELDS (UserAccount)
  int? id;
  int? userId;
  String? userName;
  String? fullName;
  String? email;
  String? contactNo;
  String? password;
  DateTime? createdAt;
  DateTime? updatedAt;
  bool? isDeleted;

  // end FIELDS (UserAccount)

  static const bool _softDeleteActivated = true;
  UserAccountManager? __mnUserAccount;

  UserAccountManager get _mnUserAccount {
    return __mnUserAccount = __mnUserAccount ?? UserAccountManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (userId != null || !forView) {
      map['userId'] = userId;
    }
    if (userName != null || !forView) {
      map['userName'] = userName;
    }
    if (fullName != null || !forView) {
      map['fullName'] = fullName;
    }
    if (email != null || !forView) {
      map['email'] = email;
    }
    if (contactNo != null || !forView) {
      map['contactNo'] = contactNo;
    }
    if (password != null || !forView) {
      map['password'] = password;
    }
    if (createdAt != null) {
      map['createdAt'] = forJson
          ? createdAt!.toString()
          : forQuery
              ? createdAt!.millisecondsSinceEpoch
              : createdAt;
    } else if (createdAt != null || !forView) {
      map['createdAt'] = null;
    }
    if (updatedAt != null) {
      map['updatedAt'] = forJson
          ? updatedAt!.toString()
          : forQuery
              ? updatedAt!.millisecondsSinceEpoch
              : updatedAt;
    } else if (updatedAt != null || !forView) {
      map['updatedAt'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (userId != null || !forView) {
      map['userId'] = userId;
    }
    if (userName != null || !forView) {
      map['userName'] = userName;
    }
    if (fullName != null || !forView) {
      map['fullName'] = fullName;
    }
    if (email != null || !forView) {
      map['email'] = email;
    }
    if (contactNo != null || !forView) {
      map['contactNo'] = contactNo;
    }
    if (password != null || !forView) {
      map['password'] = password;
    }
    if (createdAt != null) {
      map['createdAt'] = forJson
          ? createdAt!.toString()
          : forQuery
              ? createdAt!.millisecondsSinceEpoch
              : createdAt;
    } else if (createdAt != null || !forView) {
      map['createdAt'] = null;
    }
    if (updatedAt != null) {
      map['updatedAt'] = forJson
          ? updatedAt!.toString()
          : forQuery
              ? updatedAt!.millisecondsSinceEpoch
              : updatedAt;
    } else if (updatedAt != null || !forView) {
      map['updatedAt'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  /// This method returns Json String [UserAccount]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [UserAccount]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      userId,
      userName,
      fullName,
      email,
      contactNo,
      password,
      createdAt != null ? createdAt!.millisecondsSinceEpoch : null,
      updatedAt != null ? updatedAt!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      userId,
      userName,
      fullName,
      email,
      contactNo,
      password,
      createdAt != null ? createdAt!.millisecondsSinceEpoch : null,
      updatedAt != null ? updatedAt!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  static Future<List<UserAccount>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR UserAccount.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<UserAccount>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <UserAccount>[];
    try {
      objList = list
          .map((useraccount) =>
              UserAccount.fromMap(useraccount as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR UserAccount.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<UserAccount>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<UserAccount> objList = <UserAccount>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = UserAccount.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns UserAccount by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [UserAccount] if exist, otherwise returns null
  Future<UserAccount?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    UserAccount? obj;
    final data = await _mnUserAccount.getById([id]);
    if (data.length != 0) {
      obj = UserAccount.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (UserAccount) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnUserAccount.insert(this, ignoreBatch);
    } else {
      await _mnUserAccount.update(this);
    }

    return id;
  }

  /// Saves the (UserAccount) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnUserAccount.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnUserAccount.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs UserAccount. Returns a new Primary Key value of UserAccount

  /// <returns>Returns a new Primary Key value of UserAccount
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<UserAccount> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<UserAccount> useraccounts,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await KambasDB().batchStart();
    for (final obj in useraccounts) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await KambasDB().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < useraccounts.length; i++) {
        if (useraccounts[i].id == null) {
          useraccounts[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnUserAccount.rawInsert(
          'INSERT OR REPLACE INTO userAccounts (id, userId, userName, fullName, email, contactNo, password, createdAt, updatedAt,isDeleted)  VALUES (?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            userId,
            userName,
            fullName,
            email,
            contactNo,
            password,
            createdAt != null ? createdAt!.millisecondsSinceEpoch : null,
            updatedAt != null ? updatedAt!.millisecondsSinceEpoch : null,
            isDeleted
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'UserAccount id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'UserAccount id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'UserAccount Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<UserAccount>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<UserAccount> useraccounts,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnUserAccount.rawInsertAll(
        'INSERT OR REPLACE INTO userAccounts (id, userId, userName, fullName, email, contactNo, password, createdAt, updatedAt,isDeleted)  VALUES (?,?,?,?,?,?,?,?,?,?)',
        useraccounts,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes UserAccount

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete UserAccount invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnUserAccount
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnUserAccount.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover UserAccount

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  @override
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover UserAccount invoked (id=$id)');
    {
      return _mnUserAccount.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  @override
  UserAccountFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return UserAccountFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  UserAccountFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return UserAccountFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isDeleted = isDeleted ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion useraccount

// region UserAccountField
class UserAccountField extends FilterBase {
  UserAccountField(UserAccountFilterBuilder useraccountFB)
      : super(useraccountFB);

  @override
  UserAccountFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as UserAccountFilterBuilder;
  }

  @override
  UserAccountFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as UserAccountFilterBuilder;
  }

  @override
  UserAccountFilterBuilder isNull() {
    return super.isNull() as UserAccountFilterBuilder;
  }

  @override
  UserAccountFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as UserAccountFilterBuilder;
  }

  @override
  UserAccountFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as UserAccountFilterBuilder;
  }

  @override
  UserAccountFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as UserAccountFilterBuilder;
  }

  @override
  UserAccountFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as UserAccountFilterBuilder;
  }

  @override
  UserAccountFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as UserAccountFilterBuilder;
  }

  @override
  UserAccountFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as UserAccountFilterBuilder;
  }

  @override
  UserAccountFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as UserAccountFilterBuilder;
  }

  @override
  UserAccountFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as UserAccountFilterBuilder;
  }

  @override
  UserAccountFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as UserAccountFilterBuilder;
  }

  @override
  UserAccountField get not {
    return super.not as UserAccountField;
  }
}
// endregion UserAccountField

// region UserAccountFilterBuilder
class UserAccountFilterBuilder extends ConjunctionBase {
  UserAccountFilterBuilder(UserAccount obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnUserAccount = obj._mnUserAccount;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  UserAccountManager? _mnUserAccount;

  /// put the sql keyword 'AND'
  @override
  UserAccountFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  UserAccountFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  UserAccountFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  UserAccountFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  UserAccountFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  UserAccountFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  UserAccountFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  UserAccountFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  UserAccountFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  UserAccountFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  UserAccountFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  UserAccountField _setField(
      UserAccountField? field, String colName, DbType dbtype) {
    return UserAccountField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  UserAccountField? _id;
  UserAccountField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  UserAccountField? _userId;
  UserAccountField get userId {
    return _userId = _setField(_userId, 'userId', DbType.integer);
  }

  UserAccountField? _userName;
  UserAccountField get userName {
    return _userName = _setField(_userName, 'userName', DbType.text);
  }

  UserAccountField? _fullName;
  UserAccountField get fullName {
    return _fullName = _setField(_fullName, 'fullName', DbType.text);
  }

  UserAccountField? _email;
  UserAccountField get email {
    return _email = _setField(_email, 'email', DbType.text);
  }

  UserAccountField? _contactNo;
  UserAccountField get contactNo {
    return _contactNo = _setField(_contactNo, 'contactNo', DbType.text);
  }

  UserAccountField? _password;
  UserAccountField get password {
    return _password = _setField(_password, 'password', DbType.text);
  }

  UserAccountField? _createdAt;
  UserAccountField get createdAt {
    return _createdAt = _setField(_createdAt, 'createdAt', DbType.datetime);
  }

  UserAccountField? _updatedAt;
  UserAccountField get updatedAt {
    return _updatedAt = _setField(_updatedAt, 'updatedAt', DbType.datetime);
  }

  UserAccountField? _isDeleted;
  UserAccountField get isDeleted {
    return _isDeleted = _setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  /// Deletes List<UserAccount> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnUserAccount!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnUserAccount!.delete(qparams);
    }
    return r;
  }

  /// Recover List<UserAccount> bulk by query
  @override
  Future<BoolResult> recover() async {
    buildParameters(getIsDeleted: true);
    debugPrint('SQFENTITIY: recover UserAccount bulk invoked');
    return _mnUserAccount!.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from userAccounts ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnUserAccount!.updateBatch(qparams, values);
  }

  /// This method always returns [UserAccount] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> UserAccount?
  @override
  Future<UserAccount?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnUserAccount!.toList(qparams);
    final data = await objFuture;
    UserAccount? obj;
    if (data.isNotEmpty) {
      obj = UserAccount.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [UserAccount]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> UserAccount?
  @override
  Future<UserAccount> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        UserAccount();
  }

  /// This method returns int. [UserAccount]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? useraccountCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final useraccountsFuture = await _mnUserAccount!.toList(qparams);
    final int count = useraccountsFuture[0]['CNT'] as int;
    if (useraccountCount != null) {
      useraccountCount(count);
    }
    return count;
  }

  /// This method returns List<UserAccount> [UserAccount]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<UserAccount>
  @override
  Future<List<UserAccount>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<UserAccount> useraccountsData = await UserAccount.fromMapList(
        data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return useraccountsData;
  }

  /// This method returns Json String [UserAccount]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [UserAccount]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [UserAccount]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnUserAccount!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [UserAccount]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM userAccounts WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnUserAccount!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [UserAccount]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnUserAccount!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await UserAccount.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnUserAccount!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion UserAccountFilterBuilder

// region UserAccountFields
class UserAccountFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fUserId;
  static TableField get userId {
    return _fUserId =
        _fUserId ?? SqlSyntax.setField(_fUserId, 'userId', DbType.integer);
  }

  static TableField? _fUserName;
  static TableField get userName {
    return _fUserName =
        _fUserName ?? SqlSyntax.setField(_fUserName, 'userName', DbType.text);
  }

  static TableField? _fFullName;
  static TableField get fullName {
    return _fFullName =
        _fFullName ?? SqlSyntax.setField(_fFullName, 'fullName', DbType.text);
  }

  static TableField? _fEmail;
  static TableField get email {
    return _fEmail =
        _fEmail ?? SqlSyntax.setField(_fEmail, 'email', DbType.text);
  }

  static TableField? _fContactNo;
  static TableField get contactNo {
    return _fContactNo = _fContactNo ??
        SqlSyntax.setField(_fContactNo, 'contactNo', DbType.text);
  }

  static TableField? _fPassword;
  static TableField get password {
    return _fPassword =
        _fPassword ?? SqlSyntax.setField(_fPassword, 'password', DbType.text);
  }

  static TableField? _fCreatedAt;
  static TableField get createdAt {
    return _fCreatedAt = _fCreatedAt ??
        SqlSyntax.setField(_fCreatedAt, 'createdAt', DbType.datetime);
  }

  static TableField? _fUpdatedAt;
  static TableField get updatedAt {
    return _fUpdatedAt = _fUpdatedAt ??
        SqlSyntax.setField(_fUpdatedAt, 'updatedAt', DbType.datetime);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion UserAccountFields

//region UserAccountManager
class UserAccountManager extends SqfEntityProvider {
  UserAccountManager()
      : super(KambasDB(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'userAccounts';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion UserAccountManager
// region KambasTransaction
class KambasTransaction extends TableBase {
  KambasTransaction(
      {this.id,
      this.createdAt,
      this.username,
      this.ticketSeries,
      this.hasRead,
      this.jsonResponse,
      this.isDeleted}) {
    _setDefaultValues();
    softDeleteActivated = true;
  }
  KambasTransaction.withFields(this.createdAt, this.username, this.ticketSeries,
      this.hasRead, this.jsonResponse, this.isDeleted) {
    _setDefaultValues();
  }
  KambasTransaction.withId(this.id, this.createdAt, this.username,
      this.ticketSeries, this.hasRead, this.jsonResponse, this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  KambasTransaction.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['createdAt'] != null) {
      createdAt = int.tryParse(o['createdAt'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['createdAt'].toString())!)
          : DateTime.tryParse(o['createdAt'].toString());
    }
    if (o['username'] != null) {
      username = o['username'].toString();
    }
    if (o['ticketSeries'] != null) {
      ticketSeries = o['ticketSeries'].toString();
    }
    if (o['hasRead'] != null) {
      hasRead =
          o['hasRead'].toString() == '1' || o['hasRead'].toString() == 'true';
    }
    if (o['jsonResponse'] != null) {
      jsonResponse = o['jsonResponse'].toString();
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;
  }
  // FIELDS (KambasTransaction)
  int? id;
  DateTime? createdAt;
  String? username;
  String? ticketSeries;
  bool? hasRead;
  String? jsonResponse;
  bool? isDeleted;

  // end FIELDS (KambasTransaction)

  static const bool _softDeleteActivated = true;
  KambasTransactionManager? __mnKambasTransaction;

  KambasTransactionManager get _mnKambasTransaction {
    return __mnKambasTransaction =
        __mnKambasTransaction ?? KambasTransactionManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (createdAt != null) {
      map['createdAt'] = forJson
          ? createdAt!.toString()
          : forQuery
              ? createdAt!.millisecondsSinceEpoch
              : createdAt;
    } else if (createdAt != null || !forView) {
      map['createdAt'] = null;
    }
    if (username != null || !forView) {
      map['username'] = username;
    }
    if (ticketSeries != null || !forView) {
      map['ticketSeries'] = ticketSeries;
    }
    if (hasRead != null) {
      map['hasRead'] = forQuery ? (hasRead! ? 1 : 0) : hasRead;
    } else if (hasRead != null || !forView) {
      map['hasRead'] = null;
    }
    if (jsonResponse != null || !forView) {
      map['jsonResponse'] = jsonResponse;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (createdAt != null) {
      map['createdAt'] = forJson
          ? createdAt!.toString()
          : forQuery
              ? createdAt!.millisecondsSinceEpoch
              : createdAt;
    } else if (createdAt != null || !forView) {
      map['createdAt'] = null;
    }
    if (username != null || !forView) {
      map['username'] = username;
    }
    if (ticketSeries != null || !forView) {
      map['ticketSeries'] = ticketSeries;
    }
    if (hasRead != null) {
      map['hasRead'] = forQuery ? (hasRead! ? 1 : 0) : hasRead;
    } else if (hasRead != null || !forView) {
      map['hasRead'] = null;
    }
    if (jsonResponse != null || !forView) {
      map['jsonResponse'] = jsonResponse;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  /// This method returns Json String [KambasTransaction]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [KambasTransaction]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      createdAt != null ? createdAt!.millisecondsSinceEpoch : null,
      username,
      ticketSeries,
      hasRead,
      jsonResponse,
      isDeleted
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      createdAt != null ? createdAt!.millisecondsSinceEpoch : null,
      username,
      ticketSeries,
      hasRead,
      jsonResponse,
      isDeleted
    ];
  }

  static Future<List<KambasTransaction>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR KambasTransaction.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<KambasTransaction>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <KambasTransaction>[];
    try {
      objList = list
          .map((kambastransaction) => KambasTransaction.fromMap(
              kambastransaction as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR KambasTransaction.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<KambasTransaction>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<KambasTransaction> objList = <KambasTransaction>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = KambasTransaction.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns KambasTransaction by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [KambasTransaction] if exist, otherwise returns null
  Future<KambasTransaction?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    KambasTransaction? obj;
    final data = await _mnKambasTransaction.getById([id]);
    if (data.length != 0) {
      obj = KambasTransaction.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (KambasTransaction) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnKambasTransaction.insert(this, ignoreBatch);
    } else {
      await _mnKambasTransaction.update(this);
    }

    return id;
  }

  /// Saves the (KambasTransaction) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnKambasTransaction.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnKambasTransaction.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs KambasTransaction. Returns a new Primary Key value of KambasTransaction

  /// <returns>Returns a new Primary Key value of KambasTransaction
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<KambasTransaction> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<KambasTransaction> kambastransactions,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await KambasDB().batchStart();
    for (final obj in kambastransactions) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await KambasDB().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < kambastransactions.length; i++) {
        if (kambastransactions[i].id == null) {
          kambastransactions[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnKambasTransaction.rawInsert(
          'INSERT OR REPLACE INTO kambasTransactions (id, createdAt, username, ticketSeries, hasRead, jsonResponse,isDeleted)  VALUES (?,?,?,?,?,?,?)',
          [
            id,
            createdAt != null ? createdAt!.millisecondsSinceEpoch : null,
            username,
            ticketSeries,
            hasRead,
            jsonResponse,
            isDeleted
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'KambasTransaction id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'KambasTransaction id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'KambasTransaction Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<KambasTransaction>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<KambasTransaction> kambastransactions,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnKambasTransaction.rawInsertAll(
        'INSERT OR REPLACE INTO kambasTransactions (id, createdAt, username, ticketSeries, hasRead, jsonResponse,isDeleted)  VALUES (?,?,?,?,?,?,?)',
        kambastransactions,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes KambasTransaction

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete KambasTransaction invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnKambasTransaction
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnKambasTransaction.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover KambasTransaction

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  @override
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover KambasTransaction invoked (id=$id)');
    {
      return _mnKambasTransaction.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  @override
  KambasTransactionFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return KambasTransactionFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  KambasTransactionFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return KambasTransactionFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    hasRead = hasRead ?? false;
    isDeleted = isDeleted ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion kambastransaction

// region KambasTransactionField
class KambasTransactionField extends FilterBase {
  KambasTransactionField(KambasTransactionFilterBuilder kambastransactionFB)
      : super(kambastransactionFB);

  @override
  KambasTransactionFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as KambasTransactionFilterBuilder;
  }

  @override
  KambasTransactionFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as KambasTransactionFilterBuilder;
  }

  @override
  KambasTransactionFilterBuilder isNull() {
    return super.isNull() as KambasTransactionFilterBuilder;
  }

  @override
  KambasTransactionFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as KambasTransactionFilterBuilder;
  }

  @override
  KambasTransactionFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as KambasTransactionFilterBuilder;
  }

  @override
  KambasTransactionFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as KambasTransactionFilterBuilder;
  }

  @override
  KambasTransactionFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as KambasTransactionFilterBuilder;
  }

  @override
  KambasTransactionFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as KambasTransactionFilterBuilder;
  }

  @override
  KambasTransactionFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as KambasTransactionFilterBuilder;
  }

  @override
  KambasTransactionFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as KambasTransactionFilterBuilder;
  }

  @override
  KambasTransactionFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as KambasTransactionFilterBuilder;
  }

  @override
  KambasTransactionFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as KambasTransactionFilterBuilder;
  }

  @override
  KambasTransactionField get not {
    return super.not as KambasTransactionField;
  }
}
// endregion KambasTransactionField

// region KambasTransactionFilterBuilder
class KambasTransactionFilterBuilder extends ConjunctionBase {
  KambasTransactionFilterBuilder(KambasTransaction obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnKambasTransaction = obj._mnKambasTransaction;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  KambasTransactionManager? _mnKambasTransaction;

  /// put the sql keyword 'AND'
  @override
  KambasTransactionFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  KambasTransactionFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  KambasTransactionFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  KambasTransactionFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  KambasTransactionFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  KambasTransactionFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  KambasTransactionFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  KambasTransactionFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  KambasTransactionFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  KambasTransactionFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  KambasTransactionFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  KambasTransactionField _setField(
      KambasTransactionField? field, String colName, DbType dbtype) {
    return KambasTransactionField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  KambasTransactionField? _id;
  KambasTransactionField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  KambasTransactionField? _createdAt;
  KambasTransactionField get createdAt {
    return _createdAt = _setField(_createdAt, 'createdAt', DbType.datetime);
  }

  KambasTransactionField? _username;
  KambasTransactionField get username {
    return _username = _setField(_username, 'username', DbType.text);
  }

  KambasTransactionField? _ticketSeries;
  KambasTransactionField get ticketSeries {
    return _ticketSeries =
        _setField(_ticketSeries, 'ticketSeries', DbType.text);
  }

  KambasTransactionField? _hasRead;
  KambasTransactionField get hasRead {
    return _hasRead = _setField(_hasRead, 'hasRead', DbType.bool);
  }

  KambasTransactionField? _jsonResponse;
  KambasTransactionField get jsonResponse {
    return _jsonResponse =
        _setField(_jsonResponse, 'jsonResponse', DbType.text);
  }

  KambasTransactionField? _isDeleted;
  KambasTransactionField get isDeleted {
    return _isDeleted = _setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  /// Deletes List<KambasTransaction> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnKambasTransaction!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnKambasTransaction!.delete(qparams);
    }
    return r;
  }

  /// Recover List<KambasTransaction> bulk by query
  @override
  Future<BoolResult> recover() async {
    buildParameters(getIsDeleted: true);
    debugPrint('SQFENTITIY: recover KambasTransaction bulk invoked');
    return _mnKambasTransaction!.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from kambasTransactions ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnKambasTransaction!.updateBatch(qparams, values);
  }

  /// This method always returns [KambasTransaction] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> KambasTransaction?
  @override
  Future<KambasTransaction?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnKambasTransaction!.toList(qparams);
    final data = await objFuture;
    KambasTransaction? obj;
    if (data.isNotEmpty) {
      obj = KambasTransaction.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [KambasTransaction]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> KambasTransaction?
  @override
  Future<KambasTransaction> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        KambasTransaction();
  }

  /// This method returns int. [KambasTransaction]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? kambastransactionCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final kambastransactionsFuture =
        await _mnKambasTransaction!.toList(qparams);
    final int count = kambastransactionsFuture[0]['CNT'] as int;
    if (kambastransactionCount != null) {
      kambastransactionCount(count);
    }
    return count;
  }

  /// This method returns List<KambasTransaction> [KambasTransaction]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<KambasTransaction>
  @override
  Future<List<KambasTransaction>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<KambasTransaction> kambastransactionsData =
        await KambasTransaction.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return kambastransactionsData;
  }

  /// This method returns Json String [KambasTransaction]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [KambasTransaction]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [KambasTransaction]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnKambasTransaction!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [KambasTransaction]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM kambasTransactions WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnKambasTransaction!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [KambasTransaction]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnKambasTransaction!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await KambasTransaction.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnKambasTransaction!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion KambasTransactionFilterBuilder

// region KambasTransactionFields
class KambasTransactionFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fCreatedAt;
  static TableField get createdAt {
    return _fCreatedAt = _fCreatedAt ??
        SqlSyntax.setField(_fCreatedAt, 'createdAt', DbType.datetime);
  }

  static TableField? _fUsername;
  static TableField get username {
    return _fUsername =
        _fUsername ?? SqlSyntax.setField(_fUsername, 'username', DbType.text);
  }

  static TableField? _fTicketSeries;
  static TableField get ticketSeries {
    return _fTicketSeries = _fTicketSeries ??
        SqlSyntax.setField(_fTicketSeries, 'ticketSeries', DbType.text);
  }

  static TableField? _fHasRead;
  static TableField get hasRead {
    return _fHasRead =
        _fHasRead ?? SqlSyntax.setField(_fHasRead, 'hasRead', DbType.bool);
  }

  static TableField? _fJsonResponse;
  static TableField get jsonResponse {
    return _fJsonResponse = _fJsonResponse ??
        SqlSyntax.setField(_fJsonResponse, 'jsonResponse', DbType.text);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion KambasTransactionFields

//region KambasTransactionManager
class KambasTransactionManager extends SqfEntityProvider {
  KambasTransactionManager()
      : super(KambasDB(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'kambasTransactions';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion KambasTransactionManager
// region KambasTerminal
class KambasTerminal extends TableBase {
  KambasTerminal(
      {this.id,
      this.stallName,
      this.location,
      this.agent,
      this.ticketNumber,
      this.isDeleted}) {
    _setDefaultValues();
    softDeleteActivated = true;
  }
  KambasTerminal.withFields(this.stallName, this.location, this.agent,
      this.ticketNumber, this.isDeleted) {
    _setDefaultValues();
  }
  KambasTerminal.withId(this.id, this.stallName, this.location, this.agent,
      this.ticketNumber, this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  KambasTerminal.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['stallName'] != null) {
      stallName = o['stallName'].toString();
    }
    if (o['location'] != null) {
      location = o['location'].toString();
    }
    if (o['agent'] != null) {
      agent = o['agent'].toString();
    }
    if (o['ticketNumber'] != null) {
      ticketNumber = o['ticketNumber'].toString();
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;
  }
  // FIELDS (KambasTerminal)
  int? id;
  String? stallName;
  String? location;
  String? agent;
  String? ticketNumber;
  bool? isDeleted;

  // end FIELDS (KambasTerminal)

  static const bool _softDeleteActivated = true;
  KambasTerminalManager? __mnKambasTerminal;

  KambasTerminalManager get _mnKambasTerminal {
    return __mnKambasTerminal = __mnKambasTerminal ?? KambasTerminalManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (stallName != null || !forView) {
      map['stallName'] = stallName;
    }
    if (location != null || !forView) {
      map['location'] = location;
    }
    if (agent != null || !forView) {
      map['agent'] = agent;
    }
    if (ticketNumber != null || !forView) {
      map['ticketNumber'] = ticketNumber;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (stallName != null || !forView) {
      map['stallName'] = stallName;
    }
    if (location != null || !forView) {
      map['location'] = location;
    }
    if (agent != null || !forView) {
      map['agent'] = agent;
    }
    if (ticketNumber != null || !forView) {
      map['ticketNumber'] = ticketNumber;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  /// This method returns Json String [KambasTerminal]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [KambasTerminal]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [stallName, location, agent, ticketNumber, isDeleted];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [id, stallName, location, agent, ticketNumber, isDeleted];
  }

  static Future<List<KambasTerminal>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR KambasTerminal.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<KambasTerminal>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <KambasTerminal>[];
    try {
      objList = list
          .map((kambasterminal) =>
              KambasTerminal.fromMap(kambasterminal as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR KambasTerminal.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<KambasTerminal>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<KambasTerminal> objList = <KambasTerminal>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = KambasTerminal.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns KambasTerminal by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [KambasTerminal] if exist, otherwise returns null
  Future<KambasTerminal?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    KambasTerminal? obj;
    final data = await _mnKambasTerminal.getById([id]);
    if (data.length != 0) {
      obj = KambasTerminal.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (KambasTerminal) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnKambasTerminal.insert(this, ignoreBatch);
    } else {
      await _mnKambasTerminal.update(this);
    }

    return id;
  }

  /// Saves the (KambasTerminal) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnKambasTerminal.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnKambasTerminal.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs KambasTerminal. Returns a new Primary Key value of KambasTerminal

  /// <returns>Returns a new Primary Key value of KambasTerminal
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<KambasTerminal> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<KambasTerminal> kambasterminals,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await KambasDB().batchStart();
    for (final obj in kambasterminals) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await KambasDB().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < kambasterminals.length; i++) {
        if (kambasterminals[i].id == null) {
          kambasterminals[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnKambasTerminal.rawInsert(
          'INSERT OR REPLACE INTO kambasTerminal (id, stallName, location, agent, ticketNumber,isDeleted)  VALUES (?,?,?,?,?,?)',
          [id, stallName, location, agent, ticketNumber, isDeleted],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'KambasTerminal id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'KambasTerminal id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'KambasTerminal Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<KambasTerminal>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<KambasTerminal> kambasterminals,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnKambasTerminal.rawInsertAll(
        'INSERT OR REPLACE INTO kambasTerminal (id, stallName, location, agent, ticketNumber,isDeleted)  VALUES (?,?,?,?,?,?)',
        kambasterminals,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes KambasTerminal

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete KambasTerminal invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnKambasTerminal
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnKambasTerminal.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover KambasTerminal

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  @override
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover KambasTerminal invoked (id=$id)');
    {
      return _mnKambasTerminal.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  @override
  KambasTerminalFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return KambasTerminalFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  KambasTerminalFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return KambasTerminalFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    stallName = stallName ?? '';
    location = location ?? '';
    agent = agent ?? '';
    ticketNumber = ticketNumber ?? '';
    isDeleted = isDeleted ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion kambasterminal

// region KambasTerminalField
class KambasTerminalField extends FilterBase {
  KambasTerminalField(KambasTerminalFilterBuilder kambasterminalFB)
      : super(kambasterminalFB);

  @override
  KambasTerminalFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as KambasTerminalFilterBuilder;
  }

  @override
  KambasTerminalFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as KambasTerminalFilterBuilder;
  }

  @override
  KambasTerminalFilterBuilder isNull() {
    return super.isNull() as KambasTerminalFilterBuilder;
  }

  @override
  KambasTerminalFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as KambasTerminalFilterBuilder;
  }

  @override
  KambasTerminalFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as KambasTerminalFilterBuilder;
  }

  @override
  KambasTerminalFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as KambasTerminalFilterBuilder;
  }

  @override
  KambasTerminalFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as KambasTerminalFilterBuilder;
  }

  @override
  KambasTerminalFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as KambasTerminalFilterBuilder;
  }

  @override
  KambasTerminalFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as KambasTerminalFilterBuilder;
  }

  @override
  KambasTerminalFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as KambasTerminalFilterBuilder;
  }

  @override
  KambasTerminalFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as KambasTerminalFilterBuilder;
  }

  @override
  KambasTerminalFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as KambasTerminalFilterBuilder;
  }

  @override
  KambasTerminalField get not {
    return super.not as KambasTerminalField;
  }
}
// endregion KambasTerminalField

// region KambasTerminalFilterBuilder
class KambasTerminalFilterBuilder extends ConjunctionBase {
  KambasTerminalFilterBuilder(KambasTerminal obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnKambasTerminal = obj._mnKambasTerminal;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  KambasTerminalManager? _mnKambasTerminal;

  /// put the sql keyword 'AND'
  @override
  KambasTerminalFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  KambasTerminalFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  KambasTerminalFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  KambasTerminalFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  KambasTerminalFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  KambasTerminalFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  KambasTerminalFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  KambasTerminalFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  KambasTerminalFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  KambasTerminalFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  KambasTerminalFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  KambasTerminalField _setField(
      KambasTerminalField? field, String colName, DbType dbtype) {
    return KambasTerminalField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  KambasTerminalField? _id;
  KambasTerminalField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  KambasTerminalField? _stallName;
  KambasTerminalField get stallName {
    return _stallName = _setField(_stallName, 'stallName', DbType.text);
  }

  KambasTerminalField? _location;
  KambasTerminalField get location {
    return _location = _setField(_location, 'location', DbType.text);
  }

  KambasTerminalField? _agent;
  KambasTerminalField get agent {
    return _agent = _setField(_agent, 'agent', DbType.text);
  }

  KambasTerminalField? _ticketNumber;
  KambasTerminalField get ticketNumber {
    return _ticketNumber =
        _setField(_ticketNumber, 'ticketNumber', DbType.text);
  }

  KambasTerminalField? _isDeleted;
  KambasTerminalField get isDeleted {
    return _isDeleted = _setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  /// Deletes List<KambasTerminal> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnKambasTerminal!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnKambasTerminal!.delete(qparams);
    }
    return r;
  }

  /// Recover List<KambasTerminal> bulk by query
  @override
  Future<BoolResult> recover() async {
    buildParameters(getIsDeleted: true);
    debugPrint('SQFENTITIY: recover KambasTerminal bulk invoked');
    return _mnKambasTerminal!.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from kambasTerminal ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnKambasTerminal!.updateBatch(qparams, values);
  }

  /// This method always returns [KambasTerminal] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> KambasTerminal?
  @override
  Future<KambasTerminal?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnKambasTerminal!.toList(qparams);
    final data = await objFuture;
    KambasTerminal? obj;
    if (data.isNotEmpty) {
      obj = KambasTerminal.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [KambasTerminal]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> KambasTerminal?
  @override
  Future<KambasTerminal> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        KambasTerminal();
  }

  /// This method returns int. [KambasTerminal]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? kambasterminalCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final kambasterminalsFuture = await _mnKambasTerminal!.toList(qparams);
    final int count = kambasterminalsFuture[0]['CNT'] as int;
    if (kambasterminalCount != null) {
      kambasterminalCount(count);
    }
    return count;
  }

  /// This method returns List<KambasTerminal> [KambasTerminal]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<KambasTerminal>
  @override
  Future<List<KambasTerminal>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<KambasTerminal> kambasterminalsData =
        await KambasTerminal.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return kambasterminalsData;
  }

  /// This method returns Json String [KambasTerminal]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [KambasTerminal]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [KambasTerminal]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnKambasTerminal!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [KambasTerminal]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM kambasTerminal WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnKambasTerminal!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [KambasTerminal]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnKambasTerminal!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await KambasTerminal.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnKambasTerminal!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion KambasTerminalFilterBuilder

// region KambasTerminalFields
class KambasTerminalFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fStallName;
  static TableField get stallName {
    return _fStallName = _fStallName ??
        SqlSyntax.setField(_fStallName, 'stallName', DbType.text);
  }

  static TableField? _fLocation;
  static TableField get location {
    return _fLocation =
        _fLocation ?? SqlSyntax.setField(_fLocation, 'location', DbType.text);
  }

  static TableField? _fAgent;
  static TableField get agent {
    return _fAgent =
        _fAgent ?? SqlSyntax.setField(_fAgent, 'agent', DbType.text);
  }

  static TableField? _fTicketNumber;
  static TableField get ticketNumber {
    return _fTicketNumber = _fTicketNumber ??
        SqlSyntax.setField(_fTicketNumber, 'ticketNumber', DbType.text);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion KambasTerminalFields

//region KambasTerminalManager
class KambasTerminalManager extends SqfEntityProvider {
  KambasTerminalManager()
      : super(KambasDB(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'kambasTerminal';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion KambasTerminalManager
/// Region SEQUENCE IdentitySequence
class IdentitySequence {
  /// Assigns a new value when it is triggered and returns the new value
  /// returns Future<int>
  Future<int> nextVal([VoidCallback Function(int o)? nextval]) async {
    final val = await KambasDBSequenceManager()
        .sequence(SequenceIdentitySequence.getInstance, true);
    if (nextval != null) {
      nextval(val);
    }
    return val;
  }

  /// Get the current value
  /// returns Future<int>
  Future<int> currentVal([VoidCallback Function(int o)? currentval]) async {
    final val = await KambasDBSequenceManager()
        .sequence(SequenceIdentitySequence.getInstance, false);
    if (currentval != null) {
      currentval(val);
    }
    return val;
  }

  /// Reset sequence to start value
  /// returns start value
  Future<int> reset([VoidCallback Function(int o)? currentval]) async {
    final val = await KambasDBSequenceManager()
        .sequence(SequenceIdentitySequence.getInstance, false, reset: true);
    if (currentval != null) {
      currentval(val);
    }
    return val;
  }
}

/// End Region SEQUENCE IdentitySequence

class KambasDBSequenceManager extends SqfEntityProvider {
  KambasDBSequenceManager() : super(KambasDB());
}
// END OF ENTITIES
